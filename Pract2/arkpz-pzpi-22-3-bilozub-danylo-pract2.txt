МІНІСТЕРСТВО ОСВІТИ І НАУКИ УКРАЇНИ
ХАРКІВСЬКИЙ НАЦІОНАЛЬНИЙ УНІВЕРСИТЕТ РАДІОЕЛЕКТРОНІКИ




Звіт
з практичної заняття №2
 з дисципліни «Аналіз та рефакторинг коду»
на тему: «Методи рефакторингу коду програмного забезпечення»



Виконав:
студент групи ПЗПІ-22-3
Білозуб Данило  Владиславович

Перевірив:
ст. викладач кафедри ПІ
Сокорчук Ігор Петрович








Харків 2024




1 МЕТА РОБОТИ

Вивчити основні методи рефакторингу коду на основі реальних прикладів з власних програмних проєктів. Навчитися ідентифікувати проблеми в коді та використовувати відповідні методи рефакторингу для покращення його якості.

2 ВСТУП

У моїй  доповіді основна увага зосереджена на важливості покращення якості коду через його реорганізацію. Спочатку розглядаються принципи рефакторингу, які спрямовані на підвищення читабельності, зменшення складності та забезпечення масштабованості. Детально аналізуються методи, такі як заміна циклу на рекурсію для спрощення логіки, перетворення примітивних значень на об’єкти для кращої інкапсуляції даних, а також розбиття тимчасових змінних для уникнення помилок і спрощення тестування.
Ця робота допоможе мені ознайомитися з основними методами рефакторингу та зрозуміти, як їх правильно застосовувати. Завдяки цьому я зможу писати більш структурований, читабельний і зручний для підтримки код.

3 ХІД РОБОТИ

Посилання на відео з демонстраціями порад написання коду мовою PHP наведено у додатку А.

3.1 Перший метод - Розбиття тимчасової змінної

3.1.1 Загальна інформація про метод рефакторингу

Розбиття тимчасової змінної -  це метод рефакторингу, який замінює одну змінну, що використовується для різних завдань, на кілька окремих із чітким призначенням.
Цей метод допомагає зробити код:
•	Читабельним: Значення змінних легко розпізнати за їх назвою.
•	Менш схильним до помилок: Кожна змінна має лише одну мету.
•	Легким для тестування: Проміжні значення можна ізолювати для перевірки.

3.1.2 Проблеми коду до рефакторингу

До рефакторингу код містить одну змінну $temp для всіх етапів обчислення, що ускладнює його читання, тестування та підтримку. Змішування логіки призводить до неявного переназначення значень, через що легко допустити помилки.

3.1.3 Переваги коду після рефакторингу

Після рефакторингу код стає значно простішим для розуміння. Кожен етап розрахунку (ціна з податком, ціна зі знижкою, додавання вартості доставки) тепер представлений у вигляді окремих змінних з чіткими і зрозумілими іменами ($priceWithTax, $priceWithDiscount, $finalPrice). Це робить код більш логічним і зменшує ймовірність виникнення помилок.

Приклади коду до та після  рефакторингу наведено у додатку Б.

3.2 Другий метод - Замінити цикл на рекурсію

3.2.1 Загальна інформація про метод рефакторингу

Замінити цикл на рекурсію— це метод рефакторингу, який замінює ітеративний підхід (цикли) для вирішення задачі на рекурсивний. Використання рекурсії дозволяє зробити код більш лаконічним, виразним і зручним для роботи з ієрархічними або деревоподібними структурами даних.

3.2.2 Проблеми коду до рефакторингу

Цикли з вкладеними умовами ускладнюють сприйняття логіки обробки даних. Якщо в коді багато рівнів вкладеності, читачу важко зрозуміти, які умови стосуються яких операцій.
Лічильники або додаткові змінні, які використовуються в циклах, можуть заплутати, особливо якщо їх значення змінюється в різних частинах тіла циклу.
Втрата слідування за ітераціями у великих циклах може призвести до неправильного обходу даних або до нескінченних циклів.
Додавання нових вимог, наприклад, додаткових умов або операцій у циклі, призводить до збільшення його складності. Це робить код менш гнучким для модифікації та тестування.

3.2.3 Переваги коду після рефакторингу

Код став більш лаконічним та зрозумілим. Логіка з обробки черги була усунена.
Використання рекурсії дозволяє описати обхід дерева ієрархії простими викликами функції.
Рекурсія із посиланням на масив (&$subgroups) уникає зайвого копіювання даних, зберігаючи оптимальність.

Приклади коду до та після  рефакторингу наведено у додатку В.

3.3 Третій метод - Замінити значення на об’єкт

3.2.1 Загальна інформація про метод рефакторингу

Замінити значення на об’єкт— це метод рефакторингу, який перетворює примітивне значення на об’єкт, щоб покращити структуру коду та додати додаткову функціональність, пов’язану зі значенням.
Перетворення примітивного значення на об'єкт дозволяє:
•	Інкапсулювати логіку, що стосується даного значення.
•	Зробити код більш читабельним і зрозумілим.
•	Спрощувати модифікацію й тестування коду.

3.2.2 Проблеми коду до рефакторингу

"pending", "shipped", "delivered" - це прості рядки, які не мають власної поведінки.
Логіка, специфічна для статусу, дублюється в різних частинах програми.
Додавання нового статусу вимагає зміни умов у різних місцях, що збільшує ймовірність помилок.
Перевірки типу if ($currentStatus === "delivered" && $newStatus !== "returned") ускладнюють розуміння, що саме відбувається.

3.2.3 Переваги коду після рефакторингу

Логіка, пов’язана зі статусом, тепер ізольована в класі OrderStatus.
Додавання нового статусу або логіки зміни статусу потребує зміни лише в класі OrderStatus, а не в маршруті.
Код став зрозумілішим завдяки інкапсуляції перевірок і умов у методі isChangeAllowed.
Уся логіка, пов’язана зі статусами, тепер централізована в одному місці.
Приклади коду до та після  рефакторингу наведено у додатку Г.

Слайди презентації, які ілюструють результати виконання практичної роботи наведено у додатку Д.

ВИСНОВКИ

Застосування рефакторингу на основі реальних прикладів допомагає навчитися ефективно ідентифікувати проблеми в коді, такі як дублювання, складність або низька зрозумілість, і застосовувати відповідні методи для їх усунення. Це включає в себе як прості зміни, так і більш складні стратегії, які забезпечують кращу читабельність, тестованість і масштабованість коду. В результаті програміст здатний підвищити якість проєкту, зробити його більш ефективним та зручним для роботи як для себе, так і для колег.

СПИСОК ВИКОРИСТАНИХ ДЖЕРЕЛ

1. Мартін Фаулер (2018). Refactoring: Improving the Design of Existing Code. (дата  використання 07.12.2024)










ДОДАТОК А
Посилання на відео

https://youtu.be/5X50S_HU2jw – Посилання на відео з представленням доповіді.

ДОДАТОК Б
Приклади коду до та після  рефакторингу методом розбиття тимчасової змінної

1 // Розбиття тимчасової змінної
2 // Код до рефакторингу
3 
4 function calculateFinalPrice($basePrice, $taxRate, $discountRate, $shippingFee) {
5     if ($basePrice < 0 || $taxRate < 0 || $taxRate > 1 || $discountRate < 0 || $discountRate > 1 || $shippingFee < 0) {
6         throw new InvalidArgumentException("Некоректні вхідні дані.");
7     }
8 
9     $temp = $basePrice;
10 
11     // Крок 1: Розрахунок ціни з податком
12     $temp += $temp * $taxRate;
13 
14     // Крок 2: Розрахунок ціни зі знижкою
15     if ($discountRate > 0) {
16         $temp -= $temp * $discountRate;
17     }
18 
19     // Крок 3: Додавання вартості доставки
20     $temp += $shippingFee;
21 
22     return $temp;
23 }
24 
25 function generateInvoice($basePrice, $taxRate, $discountRate, $shippingFee) {
26     echo "=== Інвойс ===\n";
27     echo "Базова ціна: $" . number_format($basePrice, 2) . "\n";
28 
29     $temp = $basePrice;
30 
31     // Крок 1: Розрахунок ціни з податком
32     $temp += $temp * $taxRate;
33     echo "Ціна з податком: $" . number_format($temp, 2) . " (Податкова ставка: " . ($taxRate * 100) . "%)\n";
34 
35     // Крок 2: Розрахунок ціни зі знижкою
36     if ($discountRate > 0) {
37         $temp -= $temp * $discountRate;
38         echo "Ціна зі знижкою: $" . number_format($temp, 2) . " (Знижка: " . ($discountRate * 100) . "%)\n";
39     } else {
40         echo "Знижка не застосована.\n";
41     }
42 
43     // Крок 3: Додавання вартості доставки
44     $temp += $shippingFee;
45     echo "Вартість доставки: $" . number_format($shippingFee, 2) . "\n";
46 
47     echo "Кінцева ціна: $" . number_format($temp, 2) . "\n";
48     echo "=================\n";
49 }
50 
51 // Приклад використання
52 try {
53     $basePrice = 100.00; // Базова ціна товару
54     $taxRate = 0.2; // Податкова ставка (20%)
55     $discountRate = 0.1; // Знижка (10%)
56     $shippingFee = 15.00; // Вартість доставки
57 
58     // Розрахунок фінальної ціни
59     $finalPrice = calculateFinalPrice($basePrice, $taxRate, $discountRate, $shippingFee);
60     echo "Кінцева ціна: $" . number_format($finalPrice, 2) . "\n";
61 
62     // Генерація інвойсу
63     generateInvoice($basePrice, $taxRate, $discountRate, $shippingFee);
64 
65 } catch (InvalidArgumentException $e) {
66     echo "Помилка: " . $e->getMessage() . "\n";
67 }
68 
69 // Код після рефакторингу
70 
71 function calculateFinalPriceRefactored($basePrice, $taxRate, $discountRate, $shippingFee) {
72     if ($basePrice < 0 || $taxRate < 0 || $taxRate > 1 || $discountRate < 0 || $discountRate > 1 || $shippingFee < 0) {
73         throw new InvalidArgumentException("Некоректні вхідні дані.");
74     }
75 
76     // Крок 1: Розрахунок ціни з податком
77     $priceWithTax = $basePrice + ($basePrice * $taxRate);
78 
79     // Крок 2: Розрахунок ціни зі знижкою
80     $priceWithDiscount = ($discountRate > 0) ? $priceWithTax - ($priceWithTax * $discountRate) : $priceWithTax;
81 
82     // Крок 3: Додавання вартості доставки
83     $finalPrice = $priceWithDiscount + $shippingFee;
84 
85     return $finalPrice;
86 }
87 
88 function generateInvoiceRefactored($basePrice, $taxRate, $discountRate, $shippingFee) {
89     echo "=== Інвойс ===\n";
90     echo "Базова ціна: $" . number_format($basePrice, 2) . "\n";
91 
92     // Крок 1: Розрахунок ціни з податком
93     $priceWithTax = $basePrice + ($basePrice * $taxRate);
94     echo "Ціна з податком: $" . number_format($priceWithTax, 2) . " (Податкова ставка: " . ($taxRate * 100) . "%)\n";
95 
96     // Крок 2: Розрахунок ціни зі знижкою
97     $priceWithDiscount = ($discountRate > 0) ? $priceWithTax - ($priceWithTax * $discountRate) : $priceWithTax;
98     if ($discountRate > 0) {
99         echo "Ціна зі знижкою: $" . number_format($priceWithDiscount, 2) . " (Знижка: " . ($discountRate * 100) . "%)\n";
100     } else {
101         echo "Знижка не застосована.\n";
102     }
103 
104     // Крок 3: Додавання вартості доставки
105     echo "Вартість доставки: $" . number_format($shippingFee, 2) . "\n";
106 
107     $finalPrice = $priceWithDiscount + $shippingFee;
108     echo "Кінцева ціна: $" . number_format($finalPrice, 2) . "\n";
109     echo "=================\n";
110 }
111 
112 // Приклад використання
113 try {
114     $basePrice = 100.00; // Базова ціна товару
115     $taxRate = 0.2; // Податкова ставка (20%)
116     $discountRate = 0.1; // Знижка (10%)
117     $shippingFee = 15.00; // Вартість доставки
118 
119     // Розрахунок фінальної ціни
120     $finalPrice = calculateFinalPriceRefactored($basePrice, $taxRate, $discountRate, $shippingFee);
121     echo "Кінцева ціна: $" . number_format($finalPrice, 2) . "\n";
122 
123     // Генерація інвойсу
124     generateInvoiceRefactored($basePrice, $taxRate, $discountRate, $shippingFee);
125 
126 } catch (InvalidArgumentException $e) {
127     echo "Помилка: " . $e->getMessage() . "\n";
128 }

ДОДАТОК В
Приклади коду до та після  рефакторингу методом заміни циклу на рекурсію

1 // Замінити цикл на рекурсію
2 // Код до рефакторингу
3 
4 function getSubgroups($pdo, $groupId) {
5     $subgroups = [];
6     $queue = [$groupId];
7 
8     while (!empty($queue)) {
9         $currentId = array_shift($queue);
10 
11         // Виконання запиту для отримання підгруп
12         $stmt = $pdo->prepare("SELECT id FROM groups WHERE parent_id = ?");
13         $stmt->execute([$currentId]);
14         $results = $stmt->fetchAll(PDO::FETCH_ASSOC);
15 
16         foreach ($results as $row) {
17             $subgroups[] = $row['id'];
18             $queue[] = $row['id']; // Додаємо підгрупу до черги для подальшої обробки
19         }
20     }
21 
22     return $subgroups;
23 }
24 
25 // Код після рефакторингу
26 
27 function getSubgroupsRecursive($pdo, $groupId, &$subgroups = []) {
28     // Виконання запиту для отримання підгруп
29     $stmt = $pdo->prepare("SELECT id FROM groups WHERE parent_id = ?");
30     $stmt->execute([$groupId]);
31     $results = $stmt->fetchAll(PDO::FETCH_ASSOC);
32 
33     foreach ($results as $row) {
34         $subgroups[] = $row['id']; // Додаємо підгрупу до списку
35         getSubgroupsRecursive($pdo, $row['id'], $subgroups); // Рекурсивно обробляємо підгрупу
36     }
37 
38     return $subgroups;
39 }

ДОДАТОК Г
Приклади коду до та після  рефакторингу методом заміни значення на об'єкт

1 // Замінити значення на об’єкт
2 // Код до рефакторингу
3 
4 // Маршрут для обробки замовлення
5 $app->post('/order/{id}/update-status', function ($request, $response, $args) {
6     $orderId = $args['id'];
7     $newStatus = $request->getParsedBody()['status'];
8 
9     // Модель для отримання замовлення
10     $order = OrderModel::find($orderId);
11     if (!$order) {
12         return $response->withStatus(404)->write("Замовлення не знайдено");
13     }
14 
15     // Перевірка статусу
16     $currentStatus = $order->status;
17     if (($currentStatus === "delivered" && $newStatus !== "returned") ||
18         $currentStatus === "canceled") {
19         return $response->withStatus(400)->write("Зміна статусу неможлива");
20     }
21 
22     // Оновлення статусу
23     $order->status = $newStatus;
24     $order->save();
25 
26     return $response->withJson(["message" => "Статус оновлено"]);
27 });
28 
29 // Код після рефакторингу
30 
31 class OrderStatus {
32     private string $status;
33     private const VALID_STATUSES = [
34         'pending',
35         'shipped',
36         'delivered',
37         'returned',
38         'canceled',
39     ];
40 
41     public function __construct(string $status) {
42         if (!in_array($status, self::VALID_STATUSES, true)) {
43             throw new InvalidArgumentException("Недійсний статус: $status");
44         }
45         $this->status = $status;
46     }
47 
48     public function isChangeAllowed(OrderStatus $newStatus): bool {
49         if ($this->status === 'delivered' && $newStatus->getStatus() !== 'returned') {
50             return false;
51         }
52         if ($this->status === 'canceled') {
53             return false;
54         }
55         return true;
56     }
57 
58     public function getStatus(): string {
59         return $this->status;
60     }
61 }
62 
63 // Маршрут для обробки замовлення
64 $app->post('/order/{id}/update-status', function ($request, $response, $args) {
65     $orderId = $args['id'];
66     $newStatus = $request->getParsedBody()['status'];
67 
68     // Модель для отримання замовлення
69     $order = OrderModel::find($orderId);
70     if (!$order) {
71         return $response->withStatus(404)->write("Замовлення не знайдено");
72     }
73 
74     // Поточний статус як об'єкт
75     $currentStatus = new OrderStatus($order->status);
76     $newStatusObject = new OrderStatus($newStatus);
77 
78     // Перевірка статусу
79     if (!$currentStatus->isChangeAllowed($newStatusObject)) {
80         return $response->withStatus(400)->write("Зміна статусу неможлива");
81     }
82 
83     // Оновлення статусу
84     $order->status = $newStatusObject->getStatus();
85     $order->save();
86 
87     return $response->withJson(["message" => "Статус оновлено"]);
88 });

ДОДАТОК Д
Скриншоти презентації

 
Рисунок Д.1 – Титульний лист

 
Рисунок Д.2 – Рефакторинг

 
Рисунок Д.3 – Мартін Фаулер

 
Рисунок Д.4 – Перший метод - Розбиття тимчасової змінної

 
Рисунок Д.5 – Приклад до рефакторингу методом розбиття тимчасової змінної

 
Рисунок Д.6 – Приклад до рефакторингу методом розбиття тимчасової змінної

 
Рисунок Д.7 – Приклад після рефакторингу методом розбиття тимчасової змінної

 
Рисунок Д.8 – Приклад після рефакторингу методом розбиття тимчасової змінної

 
Рисунок Д.9 – Другий метод - Замінити цикл на рекурсію

 
Рисунок Д.10 – Приклад до рефакторингу методом заміни циклу на рекурсію

 
Рисунок Д.11 – Приклад після рефакторингу методом заміни циклу на рекурсію

 
Рисунок Д.12 – Третій метод - Замінити значення на об’єкт

 
Рисунок Д.13 – Приклад до рефакторингу м методом заміни значення на об’єкт

 
Рисунок Д.14 – Приклад після рефакторингу методом заміни значення на об’єкт

 
Рисунок Д.15 – Висновки

 
Рисунок Д.16 – Джерела
